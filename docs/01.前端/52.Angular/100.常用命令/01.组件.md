---
title: 组件
date: 2021-05-08 16:09:14
permalink: /pages/249263/
categories:
  - 前端
  - Angular
  - 常用命令
tags:
  - 
---


## 创建组件

cmd 中 输入ng g 可以显示所有可以创建的清单

创建组件

```
ng g component 组件路径  
```

组件路径如 components/news  就会在app/components 下创建一个news组件

## 绑定数据

<code-group>
  <code-block title="Html" active>
  ```html
 {{message}}
  ```
  </code-block>

  <code-block title=".ts">
  ```ts
  message="我是小雨"
  ```
  </code-block>
</code-group>

::: note 网页中效果
我是小雨
:::

## 属性绑定

<code-group>
  <code-block title="Html" active>
  ```html
 <h1 [title]="title_ll">{{message}}</h1>
  ```
  </code-block>

  <code-block title=".ts">
  ```ts
 title_ll = "明天就是春节";
  ```
  </code-block>
</code-group>

::: note 网页中效果



![image-20210211154249790]![](https://gitee.com/lukexiaoasusual/images/raw/master/img/image-20210211154249790.png)

:::

### ngclass



## 绑定解析Html

<code-group>
  <code-block title="Html" active>
  ```html
 <span [innerHTML]="content"></span>
  ```
  </code-block>

  <code-block title=".ts">
  ```ts
 content = "<h1>我是你的小哥哥</h1>";
  ```
  </code-block>
</code-group>

::: note 网页中效果
我是你的小哥哥
:::

## 数据循环

<code-group>
  <code-block title="Html" active>
  ```html
 <h1>一个星期里有</h1>
<ul>
  <li *ngFor="let i of xingqi">
    {{i}}
  </li>
</ul>
  ```
  </code-block>

  <code-block title=".ts">
  ```ts
 xingqi = ['星期1','星期2','星期3','星期4','星期5','星期6','星期7'];
  ```
  </code-block>
</code-group>

::: note 网页中效果
一个星期里有
星期1
星期2
星期3
星期4
星期5
星期6
星期7
:::

### 限制循环次数

```html
<li *ngFor="let i of customer.slice(0,2)">    
```

.slice属性，第一个参数是开始的序号，第2个是结束的序号，不包括结束的那个号

同样也是用于单个元素

```html
 {{i.name.slice(0,2)}}
```



### 显示数据的索引

```
<li *ngFor="let i of customer;let key=index">    
{{key}}--{{i}}
```

index为数据的索引，从0开始

### trackBy

在数据频繁刷新的时候，浏览器会重新加载数据，对于没有改变的数据，采用trackBy,dom不会重新加载

例子

html

```html
<ul>
<!--  这里循环一个list,trackBy绑定一个方法-->
  <li *ngFor="let item of list;let i=index;trackBy:trackById">{{i}}--{{item.name}}</li>
</ul>
<!--这里的rest我们绑定的把list数据换一下，部分内容改变-->
<button (click)="rest()">rest</button>

```

ts

```typescript
import {Component, OnInit} from '@angular/core';


interface Hear { // 设定的一个接口，用来约束
  id: string;
  name: string;
}


@Component({
  selector: 'app-header',
  templateUrl: './header.component.html',
  styleUrls: ['./header.component.scss']
})
export class HeaderComponent implements OnInit {
  list: Hear[] = [{    // 这是list初始数组
    id: '1',
    name: 'xiaoyu'
  },
    {
      id: '2',
      name: 'ruru'
    },
    {
      id: '3',
      name: 'yeye'
    },
  ];

  trackById(hear: Hear): string {  // 该方法返回一个Hear类型的id
    return hear.id;
  }
  rest(){     // 刷新list数组的值，2号没有改变
    this.list=[{
      id: '1',
      name: 'xiaoyu5'
    },
      {
        id: '2',
        name: 'ruru'
      },
      {
        id: '3',
        name: 'yeye3'
      },
    ];
  }


  constructor() {
  }


  ngOnInit(): void {


  }

}

```

![image-20210426204241248](https://gitee.com/lukexiaoasusual/images/raw/master/img/image-20210426204241248.png)

点击rest，数据将会发生改变，dom应该重新加载，但是，有trackBy,所以不变的数据不会重新加载

![image-20210426204339234](https://gitee.com/lukexiaoasusual/images/raw/master/img/image-20210426204339234.png)

这里1-ruru并没有重新生成dom给加载节省时间

在以后的ngfor中基本都要加trackBy特别是要刷新数据的。不然数据量大会卡死

## 引入图片

1.首先把图片引入到静态资源中，放入assets目录

```html
<img src="assets/image/alita.jpeg">
```



2.也可以引入图片的地址

<code-group>
  <code-block title="Html" active>
  ```html
 <img [src]="imag_wow">
  ```
  </code-block>

  <code-block title=".ts">
  ```ts
 imag_wow ="https://xxx/aaa/www.jpg";
  ```
  </code-block>
</code-group>



## 条件判断

### *ngif

普通用法

```html
<!--是true就显示标签,false就不显示-->
<p *ngif="true">haha</p>
<p *ngif="1>5">haha</p>
```

else用法

```html
<!--如果是真就显示当前标签，如果是假就显示two模板-->
<div *ngIf="true else two" >
  <p>one</p>
</div>
<!--这里用ng-template包裹，-->
<ng-template #two>
<div >
  <p>two</p>
</div>
</ng-template>

```



### ngif和ngfor同事使用

因为同一个标签里是不可以同事写两个的，所以前面加个ng-container

```html
<ng-container *ngFor="let i of twostep">
    <option *ngIf="i.onename==threestep.onename">{{i.name}}</option>
  </ng-container>
```



### ngswitch

<code-group>
  <code-block title="Html" active>
  ```html
 <h1 *ngFor="let i of occupation" [ngSwitch]="i">
  <p *ngSwitchCase="fashi" class="bl">{{i}}</p>
  <p *ngSwitchCase="zhanshi" class="zs">{{i}}</p>
  <p *ngSwitchCase="shushi" class="ss">{{i}}</p>
  <p *ngSwitchCase="qishi" class="qs">{{i}}</p>
  <p *ngSwitchCase="daozei" class="dz">{{i}}</p>

</h1>
  ```
  </code-block>

  <code-block title=".ts">
  ```ts
 occupation =['战士','法师','术士','骑士','盗贼'];
  fashi ='法师';
  zhanshi = '战士';
  shushi = '术士';
  qishi = '骑士';
  daozei = '盗贼';
  ```
  </code-block>

  <code-block title=".scss">
  ```scss
 .bl{
  color: blue;
}
.zs{
  color: rgba(93,82,7,0.23);
}
.ss{
  color:purple;
}
.qs{
  color: hotpink;
}
.dz{
  color: yellow;
}
  ```
  </code-block>
</code-group>

::: note 网页中效果

![](https://gitee.com/lukexiaoasusual/images/raw/master/img/image-20210213092057736.png)

:::



## 点击事件click

<code-group>
  <code-block title="Html" active>
  ```html
 <p [ngClass]="{'bl':kongzhiyanse==1,'zs':kongzhiyanse==2,'qs':kongzhiyanse==3,'ss':kongzhiyanse==4,'dz':kongzhiyanse==5}">我们来看下颜色的改变</p>
<button (click)="change()">改变颜色</button><button (click)="again()">重置</button>
  ```
  </code-block>

  <code-block title=".ts">
  ```ts
 change(){
    this.kongzhiyanse++;
  }

  again(){
    this.kongzhiyanse = 1;
  }
  ```
  </code-block>
</code-group>

## 键盘事件

### keyup

键盘弹起的时候触发的事件，也可以keyup.xx，可以具体到哪个键

```html
<input type="text" [(ngModel)]="pattern" (keyup)="run()">
```

```html
<input type="text" [(ngModel)]="pattern" (keyup.enter)="run()">
```



### keydown

键盘下压的时候触发的事件，也可以keydown.xx，可以具体到哪个键

```html
<input type="text" [(ngModel)]="pattern" (keydown)="run()">
<input type="text" [(ngModel)]="pattern" (keydown.enter)="run()">
```



## 双向数据绑定

及MVVM，视图与model的双向绑定

MVVM只是针对表单

### 引入FormModule

modules.ts里做引入

```typescript
import {FormsModule} from '@angular/forms';


@NgModule({
imports: [
    BrowserModule,
    AppRoutingModule,
   
    FormsModule

  ],

})
```

<code-group>
  <code-block title="Html" active>
  ```html
<input type="text" [(ngModel)]="model_a">
{{model_a}}
  ```
  </code-block>

  <code-block title=".ts">
  ```ts
model_a = "今天是大年初三";
  ```
  </code-block>
</code-group>

这样就可以实现，输入框，和展示框数据互相绑定，且同步

## 输入输出

### input

就是相当于定义了子组件的属性，然后在父组件中调用这个属性，将父组件的值赋值给这个属性

子组件中

```html
<button [class]="class">{{title}}</button>
```

```typescript
 @Input() title: any = '我是一个按钮';
  @Input() class: any = 'btn btn-primary';
```

我们看见属性可以给初始值的，如果父组件不重新赋值，那么就是现实的初始值

然后父组件中使用

```html
<app-feeter></app-feeter>
```

这里我们看到，我们现在没有给组件属性赋值，所以显示的就是初始默认值

效果：

![image-20210422093003790](https://gitee.com/lukexiaoasusual/images/raw/master/img/image-20210422093003790.png)

对的，这里显示的就是默认值

现在我们在父组件中对其属性进行赋值

首先我们给父组件一点值

```typescript
title: any = '我是headr里的buton';
  claas: any = 'btn btn-danger';
```

给组件赋值

```html
<app-feeter [title]="title" [class]="claas"></app-feeter>
```

现在的效果：

![image-20210422093228309](https://gitee.com/lukexiaoasusual/images/raw/master/img/image-20210422093228309.png)

没错，我们可以看到现在已经是用的父组件的属性了

非常方便，这样就避免了我们组件重写了，

直接调用即可

### output









